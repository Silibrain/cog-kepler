'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
// Copyright (c) 2018 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

function getUniforms() {
  return {};
}

var vs = 'uniform vec2 brushing_uMousePosition;\nuniform float brushing_uBrushRadius;\nuniform float brushing_uBrushSource;\nuniform float brushing_uBrushTarget;\nuniform float brushing_uEnableBrushing;\nuniform float brushing_uStrokeScale;\nuniform float brushing_uOutsideBrushRadius;\n\nconst float R_EARTH = 6371000.; // earth radius in meter\n// const float PI = 3.1415926538;\n\n// approximate distance between lng lat in meters\nfloat distanceBetweenLatLng(vec2 source, vec2 target) {\n  float PI = 3.1415926538;\n  vec2 delta = (source - target) * PI / 180.;\n\n  float a =\n    sin(delta.y / 2.) * sin(delta.y / 2.) +\n    cos(source.y * PI / 180.) * cos(target.y * PI / 180.) *\n    sin(delta.x / 2.) * sin(delta.x / 2.);\n\n  float c = 2. * atan(sqrt(a), sqrt(1. - a));\n\n  return R_EARTH * c;\n}\n\n// range is km\nfloat isPointInRange(vec2 ptLatLng, float enabled) {\n  return float(enabled <= 0. || distanceBetweenLatLng(ptLatLng, brushing_uMousePosition) <= brushing_uBrushRadius);\n}\n\nvec2 getExtrusionOffset(vec2 line_clipspace, vec2 viewportSize, float offset_direction, float lineWidth) {\n  // normalized direction of the line\n  vec2 dir_screenspace = normalize(line_clipspace * viewportSize);\n  // rotate by 90 degrees\n  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\n\n  vec2 offset_screenspace = dir_screenspace * offset_direction * lineWidth / 2.0;\n  vec2 offset_clipspace = offset_screenspace / viewportSize * 2.0;\n\n  return offset_clipspace;\n}\n\nvec2 brushing_getExtrusionOffset(\n  vec2 line_clipspace,\n  float offset_direction,\n  vec2 viewportSize,\n  vec4 instancePositions, \n  float instanceStrokeWidth\n) {\n  float isSourceInBrush = isPointInRange(instancePositions.xy, brushing_uBrushSource);\n  float isTargetInBrush = isPointInRange(instancePositions.zw, brushing_uBrushTarget);\n  \n  float isInBrush = float(brushing_uEnableBrushing <= 0. ||\n  (brushing_uBrushSource * isSourceInBrush > 0. || brushing_uBrushTarget * isTargetInBrush > 0.));\n  \n  float strokeWidth = brushing_uStrokeScale * instanceStrokeWidth;\n\n  float finalWidth = mix(0.0, strokeWidth, isInBrush);\n\n  // extrude\n  return getExtrusionOffset(line_clipspace, viewportSize, offset_direction, finalWidth);\n}\n\nfloat brushing_getRadius(\n  vec3 instancePositions,\n  float instanceRadius\n) {\n  float isPtInBrush = isPointInRange(instancePositions.xy, brushing_uEnableBrushing);\n  return mix(brushing_uOutsideBrushRadius, instanceRadius, isPtInBrush);\n}\n';

exports.default = {
  name: 'brushing',
  vs: vs,
  getUniforms: getUniforms
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zaGFkZXJsaWIvYnJ1c2hpbmctbW9kdWxlLmpzIl0sIm5hbWVzIjpbImdldFVuaWZvcm1zIiwidnMiLCJuYW1lIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVNBLFdBQVQsR0FBdUI7QUFDckIsU0FBTyxFQUFQO0FBQ0Q7O0FBRUQsSUFBTUMsKzdFQUFOOztrQkEwRWU7QUFDYkMsUUFBTSxVQURPO0FBRWJELFFBRmE7QUFHYkQ7QUFIYSxDIiwiZmlsZSI6ImJydXNoaW5nLW1vZHVsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxOCBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIGdldFVuaWZvcm1zKCkge1xuICByZXR1cm4ge307XG59XG5cbmNvbnN0IHZzID0gYFxcXG51bmlmb3JtIHZlYzIgYnJ1c2hpbmdfdU1vdXNlUG9zaXRpb247XG51bmlmb3JtIGZsb2F0IGJydXNoaW5nX3VCcnVzaFJhZGl1cztcbnVuaWZvcm0gZmxvYXQgYnJ1c2hpbmdfdUJydXNoU291cmNlO1xudW5pZm9ybSBmbG9hdCBicnVzaGluZ191QnJ1c2hUYXJnZXQ7XG51bmlmb3JtIGZsb2F0IGJydXNoaW5nX3VFbmFibGVCcnVzaGluZztcbnVuaWZvcm0gZmxvYXQgYnJ1c2hpbmdfdVN0cm9rZVNjYWxlO1xudW5pZm9ybSBmbG9hdCBicnVzaGluZ191T3V0c2lkZUJydXNoUmFkaXVzO1xuXG5jb25zdCBmbG9hdCBSX0VBUlRIID0gNjM3MTAwMC47IC8vIGVhcnRoIHJhZGl1cyBpbiBtZXRlclxuLy8gY29uc3QgZmxvYXQgUEkgPSAzLjE0MTU5MjY1Mzg7XG5cbi8vIGFwcHJveGltYXRlIGRpc3RhbmNlIGJldHdlZW4gbG5nIGxhdCBpbiBtZXRlcnNcbmZsb2F0IGRpc3RhbmNlQmV0d2VlbkxhdExuZyh2ZWMyIHNvdXJjZSwgdmVjMiB0YXJnZXQpIHtcbiAgZmxvYXQgUEkgPSAzLjE0MTU5MjY1Mzg7XG4gIHZlYzIgZGVsdGEgPSAoc291cmNlIC0gdGFyZ2V0KSAqIFBJIC8gMTgwLjtcblxuICBmbG9hdCBhID1cbiAgICBzaW4oZGVsdGEueSAvIDIuKSAqIHNpbihkZWx0YS55IC8gMi4pICtcbiAgICBjb3Moc291cmNlLnkgKiBQSSAvIDE4MC4pICogY29zKHRhcmdldC55ICogUEkgLyAxODAuKSAqXG4gICAgc2luKGRlbHRhLnggLyAyLikgKiBzaW4oZGVsdGEueCAvIDIuKTtcblxuICBmbG9hdCBjID0gMi4gKiBhdGFuKHNxcnQoYSksIHNxcnQoMS4gLSBhKSk7XG5cbiAgcmV0dXJuIFJfRUFSVEggKiBjO1xufVxuXG4vLyByYW5nZSBpcyBrbVxuZmxvYXQgaXNQb2ludEluUmFuZ2UodmVjMiBwdExhdExuZywgZmxvYXQgZW5hYmxlZCkge1xuICByZXR1cm4gZmxvYXQoZW5hYmxlZCA8PSAwLiB8fCBkaXN0YW5jZUJldHdlZW5MYXRMbmcocHRMYXRMbmcsIGJydXNoaW5nX3VNb3VzZVBvc2l0aW9uKSA8PSBicnVzaGluZ191QnJ1c2hSYWRpdXMpO1xufVxuXG52ZWMyIGdldEV4dHJ1c2lvbk9mZnNldCh2ZWMyIGxpbmVfY2xpcHNwYWNlLCB2ZWMyIHZpZXdwb3J0U2l6ZSwgZmxvYXQgb2Zmc2V0X2RpcmVjdGlvbiwgZmxvYXQgbGluZVdpZHRoKSB7XG4gIC8vIG5vcm1hbGl6ZWQgZGlyZWN0aW9uIG9mIHRoZSBsaW5lXG4gIHZlYzIgZGlyX3NjcmVlbnNwYWNlID0gbm9ybWFsaXplKGxpbmVfY2xpcHNwYWNlICogdmlld3BvcnRTaXplKTtcbiAgLy8gcm90YXRlIGJ5IDkwIGRlZ3JlZXNcbiAgZGlyX3NjcmVlbnNwYWNlID0gdmVjMigtZGlyX3NjcmVlbnNwYWNlLnksIGRpcl9zY3JlZW5zcGFjZS54KTtcblxuICB2ZWMyIG9mZnNldF9zY3JlZW5zcGFjZSA9IGRpcl9zY3JlZW5zcGFjZSAqIG9mZnNldF9kaXJlY3Rpb24gKiBsaW5lV2lkdGggLyAyLjA7XG4gIHZlYzIgb2Zmc2V0X2NsaXBzcGFjZSA9IG9mZnNldF9zY3JlZW5zcGFjZSAvIHZpZXdwb3J0U2l6ZSAqIDIuMDtcblxuICByZXR1cm4gb2Zmc2V0X2NsaXBzcGFjZTtcbn1cblxudmVjMiBicnVzaGluZ19nZXRFeHRydXNpb25PZmZzZXQoXG4gIHZlYzIgbGluZV9jbGlwc3BhY2UsXG4gIGZsb2F0IG9mZnNldF9kaXJlY3Rpb24sXG4gIHZlYzIgdmlld3BvcnRTaXplLFxuICB2ZWM0IGluc3RhbmNlUG9zaXRpb25zLCBcbiAgZmxvYXQgaW5zdGFuY2VTdHJva2VXaWR0aFxuKSB7XG4gIGZsb2F0IGlzU291cmNlSW5CcnVzaCA9IGlzUG9pbnRJblJhbmdlKGluc3RhbmNlUG9zaXRpb25zLnh5LCBicnVzaGluZ191QnJ1c2hTb3VyY2UpO1xuICBmbG9hdCBpc1RhcmdldEluQnJ1c2ggPSBpc1BvaW50SW5SYW5nZShpbnN0YW5jZVBvc2l0aW9ucy56dywgYnJ1c2hpbmdfdUJydXNoVGFyZ2V0KTtcbiAgXG4gIGZsb2F0IGlzSW5CcnVzaCA9IGZsb2F0KGJydXNoaW5nX3VFbmFibGVCcnVzaGluZyA8PSAwLiB8fFxuICAoYnJ1c2hpbmdfdUJydXNoU291cmNlICogaXNTb3VyY2VJbkJydXNoID4gMC4gfHwgYnJ1c2hpbmdfdUJydXNoVGFyZ2V0ICogaXNUYXJnZXRJbkJydXNoID4gMC4pKTtcbiAgXG4gIGZsb2F0IHN0cm9rZVdpZHRoID0gYnJ1c2hpbmdfdVN0cm9rZVNjYWxlICogaW5zdGFuY2VTdHJva2VXaWR0aDtcblxuICBmbG9hdCBmaW5hbFdpZHRoID0gbWl4KDAuMCwgc3Ryb2tlV2lkdGgsIGlzSW5CcnVzaCk7XG5cbiAgLy8gZXh0cnVkZVxuICByZXR1cm4gZ2V0RXh0cnVzaW9uT2Zmc2V0KGxpbmVfY2xpcHNwYWNlLCB2aWV3cG9ydFNpemUsIG9mZnNldF9kaXJlY3Rpb24sIGZpbmFsV2lkdGgpO1xufVxuXG5mbG9hdCBicnVzaGluZ19nZXRSYWRpdXMoXG4gIHZlYzMgaW5zdGFuY2VQb3NpdGlvbnMsXG4gIGZsb2F0IGluc3RhbmNlUmFkaXVzXG4pIHtcbiAgZmxvYXQgaXNQdEluQnJ1c2ggPSBpc1BvaW50SW5SYW5nZShpbnN0YW5jZVBvc2l0aW9ucy54eSwgYnJ1c2hpbmdfdUVuYWJsZUJydXNoaW5nKTtcbiAgcmV0dXJuIG1peChicnVzaGluZ191T3V0c2lkZUJydXNoUmFkaXVzLCBpbnN0YW5jZVJhZGl1cywgaXNQdEluQnJ1c2gpO1xufVxuYDtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnYnJ1c2hpbmcnLFxuICB2cyxcbiAgZ2V0VW5pZm9ybXNcbn07XG4iXX0=