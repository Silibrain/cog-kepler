// Copyright (c) 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

import { isBrowser } from './globals';
import { enhancePointerEventInput, enhanceMouseInput } from './hammer-overrides';

var hammerjs = void 0;
if (isBrowser) {
  hammerjs = require('hammerjs');
}

// Hammer.Manager mock for use in environments without `document` / `window`.
function HammerManagerMock(m) {
  var instance = {};
  var chainedNoop = function chainedNoop() {
    return instance;
  };
  instance.get = function () {
    return null;
  };
  instance.set = chainedNoop;
  instance.on = chainedNoop;
  instance.off = chainedNoop;
  instance.destroy = chainedNoop;
  instance.emit = chainedNoop;
  return instance;
}

if (hammerjs) {
  enhancePointerEventInput(hammerjs.PointerEventInput);
  enhanceMouseInput(hammerjs.MouseInput);
}

export var Manager = hammerjs ? hammerjs.Manager : HammerManagerMock;

export default hammerjs;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9oYW1tZXIuanMiXSwibmFtZXMiOlsiaXNCcm93c2VyIiwiZW5oYW5jZVBvaW50ZXJFdmVudElucHV0IiwiZW5oYW5jZU1vdXNlSW5wdXQiLCJoYW1tZXJqcyIsInJlcXVpcmUiLCJIYW1tZXJNYW5hZ2VyTW9jayIsIm0iLCJpbnN0YW5jZSIsImNoYWluZWROb29wIiwiZ2V0Iiwic2V0Iiwib24iLCJvZmYiLCJkZXN0cm95IiwiZW1pdCIsIlBvaW50ZXJFdmVudElucHV0IiwiTW91c2VJbnB1dCIsIk1hbmFnZXIiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVFBLFNBQVIsUUFBd0IsV0FBeEI7QUFDQSxTQUFRQyx3QkFBUixFQUFrQ0MsaUJBQWxDLFFBQTBELG9CQUExRDs7QUFFQSxJQUFJQyxpQkFBSjtBQUNBLElBQUlILFNBQUosRUFBZTtBQUNiRyxhQUFXQyxRQUFRLFVBQVIsQ0FBWDtBQUNEOztBQUVEO0FBQ0EsU0FBU0MsaUJBQVQsQ0FBMkJDLENBQTNCLEVBQThCO0FBQzVCLE1BQU1DLFdBQVcsRUFBakI7QUFDQSxNQUFNQyxjQUFjLFNBQWRBLFdBQWM7QUFBQSxXQUFNRCxRQUFOO0FBQUEsR0FBcEI7QUFDQUEsV0FBU0UsR0FBVCxHQUFlO0FBQUEsV0FBTSxJQUFOO0FBQUEsR0FBZjtBQUNBRixXQUFTRyxHQUFULEdBQWVGLFdBQWY7QUFDQUQsV0FBU0ksRUFBVCxHQUFjSCxXQUFkO0FBQ0FELFdBQVNLLEdBQVQsR0FBZUosV0FBZjtBQUNBRCxXQUFTTSxPQUFULEdBQW1CTCxXQUFuQjtBQUNBRCxXQUFTTyxJQUFULEdBQWdCTixXQUFoQjtBQUNBLFNBQU9ELFFBQVA7QUFDRDs7QUFFRCxJQUFJSixRQUFKLEVBQWM7QUFDWkYsMkJBQXlCRSxTQUFTWSxpQkFBbEM7QUFDQWIsb0JBQWtCQyxTQUFTYSxVQUEzQjtBQUNEOztBQUVELE9BQU8sSUFBTUMsVUFBVWQsV0FBV0EsU0FBU2MsT0FBcEIsR0FBOEJaLGlCQUE5Qzs7QUFFUCxlQUFlRixRQUFmIiwiZmlsZSI6ImhhbW1lci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAoYykgMjAxNyBVYmVyIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4vLyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4vLyBUSEUgU09GVFdBUkUuXG5cbmltcG9ydCB7aXNCcm93c2VyfSBmcm9tICcuL2dsb2JhbHMnO1xuaW1wb3J0IHtlbmhhbmNlUG9pbnRlckV2ZW50SW5wdXQsIGVuaGFuY2VNb3VzZUlucHV0fSBmcm9tICcuL2hhbW1lci1vdmVycmlkZXMnO1xuXG5sZXQgaGFtbWVyanM7XG5pZiAoaXNCcm93c2VyKSB7XG4gIGhhbW1lcmpzID0gcmVxdWlyZSgnaGFtbWVyanMnKTtcbn1cblxuLy8gSGFtbWVyLk1hbmFnZXIgbW9jayBmb3IgdXNlIGluIGVudmlyb25tZW50cyB3aXRob3V0IGBkb2N1bWVudGAgLyBgd2luZG93YC5cbmZ1bmN0aW9uIEhhbW1lck1hbmFnZXJNb2NrKG0pIHtcbiAgY29uc3QgaW5zdGFuY2UgPSB7fTtcbiAgY29uc3QgY2hhaW5lZE5vb3AgPSAoKSA9PiBpbnN0YW5jZTtcbiAgaW5zdGFuY2UuZ2V0ID0gKCkgPT4gbnVsbDtcbiAgaW5zdGFuY2Uuc2V0ID0gY2hhaW5lZE5vb3A7XG4gIGluc3RhbmNlLm9uID0gY2hhaW5lZE5vb3A7XG4gIGluc3RhbmNlLm9mZiA9IGNoYWluZWROb29wO1xuICBpbnN0YW5jZS5kZXN0cm95ID0gY2hhaW5lZE5vb3A7XG4gIGluc3RhbmNlLmVtaXQgPSBjaGFpbmVkTm9vcDtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5pZiAoaGFtbWVyanMpIHtcbiAgZW5oYW5jZVBvaW50ZXJFdmVudElucHV0KGhhbW1lcmpzLlBvaW50ZXJFdmVudElucHV0KTtcbiAgZW5oYW5jZU1vdXNlSW5wdXQoaGFtbWVyanMuTW91c2VJbnB1dCk7XG59XG5cbmV4cG9ydCBjb25zdCBNYW5hZ2VyID0gaGFtbWVyanMgPyBoYW1tZXJqcy5NYW5hZ2VyIDogSGFtbWVyTWFuYWdlck1vY2s7XG5cbmV4cG9ydCBkZWZhdWx0IGhhbW1lcmpzO1xuIl19